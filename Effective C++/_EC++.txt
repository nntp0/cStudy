1. Allocation / Construction 의 차이
2. Deleter 를 빼고 구현합니다. / Ptr & PtrArr 로 구분해서 구현하세요.

3. Unique_ptr 구현 및 제출 해야합니다.
    - 헤더/ cpp 


암시적 인터페이스란?
    암시적 인터페이스의 주요 요소는 유효 표현식입니다. 즉 템플릿 클래스를 이용해 정의된 시그니처를 형변환을 통해 표현할 수 있는 모임, 집합중 하나를 제공하면 되기 때문입니다.

의존 이름?
중첩 의존 타입 이름?
비의존 이름?

중첩 의존 이름은 기본적으로 타입이 아닌 것으로 가정하게 되어있습니다.
=> 중첩 의존 이름이 타입이라는 것을 컴파일러에게 알려주려면, typename 이라는 키워드를 해당 중첩 의존 이름 앞에 명시합니다.
* 단 예외가 존재합니다. 기본 클래스 리스트, 혹은 멤버 초기화 리스트 내의 리스트에 존재하는 경우 typename 을 붙이지 않습니다.

std::iterator_traits<IterT>::value_type?
    IterT 라는 템플릿 매개변수라는 객체로 가리키는 대상의 타입

완전 템플릿 특수화?
어떤 클래스의 기본 클래스가 템플릿 클래스인 경우, 파생 클래스는 기본 클래스의 멤버에 접근하는 것을 기본적으로, 꺼려합니다. (이유는 책에 자세히 나와있습니다.)
* 객체지향 C++ -> 템플릿지향 C++ 로 넘어가면, 상속의 개념이 희미해집니다.
=> 해결하려면, 기본 클래스에 해당 내용이 존재한다는 것을 명시해줘야합니다. 1.) this-> 2) 헤더에 using 기본클래스<template>::함수명; 3) 기본클래스에 있다는 것을 명시
* 가시성을 해결해야합니다.

44. 템플릿 매개변수를 사용하지 않는 코드는 템플릿으로부터 분리합시다.

    - 비타입 매개변수?
    - 코드 비대화

45. 호환되는 모든 타입을 받아들이는 데는 멤버함수 템플릿이 직방!

    - 멤버함수 템플릿?
        어떤 클래스의 멤버함수를 찍어내는 템플릿을 말합니다.
    - 일반화 복사 생성자?
    * 일반화 복사 생성자는 컴파일러가 취급하는 복사 생성자와 다른 존재입니다. 따라서, 컴파일러가 기본적으로 제공하는 생성자들의 규칙에 영향을 미치지 않습니다.

    * 템플릿 인자추론에서는 암시적 타입 변환이 고려되지 않습니다.
    => 이를 해결하려면, 클래스 템플릿 내에 friend 함수로 비멤버 함수를 선언합니다.

    * 함수와 함수 템플릿은 명확히 다릅니다.